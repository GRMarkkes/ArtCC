import { __assign, __awaiter, __generator, __spreadArray } from "tslib";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useCallback, useLayoutEffect, useState, cloneElement, useRef, } from "react";
import { computePosition, flip, offset as floatingOffset, shift, } from "@floating-ui/dom";
import "./styles.scss";
export var Floater = function (_a) {
    var triggerEl = _a.triggerEl, children = _a.children, placement = _a.placement, isVisible = _a.isVisible, _b = _a.offset, offset = _b === void 0 ? 8 : _b, _c = _a.padding, padding = _c === void 0 ? 24 : _c, hasActiveInsideClick = _a.hasActiveInsideClick, _d = _a.isContrast, isContrast = _d === void 0 ? true : _d;
    var parentRef = useRef(null);
    var floaterRef = useRef(null);
    var _e = useState(Boolean(isVisible)), isFloaterOpen = _e[0], setIsFloaterOpen = _e[1];
    var isStatic = isVisible !== undefined;
    var triggerClass = "trigger";
    var triggerActiveClass = "trigger--active";
    var delay = 150;
    var openFloater = useCallback(function () {
        var _a;
        var computeFloaterPosition = function () { return __awaiter(void 0, void 0, void 0, function () {
            var _a, x, y;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!((parentRef === null || parentRef === void 0 ? void 0 : parentRef.current) && (floaterRef === null || floaterRef === void 0 ? void 0 : floaterRef.current))) return [3, 2];
                        return [4, computePosition(parentRef.current, floaterRef.current, {
                                placement: placement,
                                middleware: [floatingOffset(offset), flip(), shift({ padding: padding })],
                            })];
                    case 1:
                        _a = _b.sent(), x = _a.x, y = _a.y;
                        Object.assign(floaterRef.current.style, {
                            left: "".concat(x, "px"),
                            top: "".concat(y, "px"),
                            transform: "translateX(0)",
                        });
                        _b.label = 2;
                    case 2: return [2];
                }
            });
        }); };
        (_a = parentRef.current) === null || _a === void 0 ? void 0 : _a.classList.add(triggerClass);
        computeFloaterPosition();
        var t = setTimeout(function () {
            var _a, _b;
            if ((_a = parentRef.current) === null || _a === void 0 ? void 0 : _a.classList.contains(triggerClass)) {
                (_b = parentRef.current) === null || _b === void 0 ? void 0 : _b.classList.add(triggerActiveClass);
                clearTimeout(t);
                setIsFloaterOpen(true);
            }
        }, delay);
    }, [offset, padding, placement]);
    var closeFloater = useCallback(function () {
        var _a;
        (_a = parentRef.current) === null || _a === void 0 ? void 0 : _a.classList.remove(triggerActiveClass);
        var t = setTimeout(function () {
            var _a;
            (_a = parentRef.current) === null || _a === void 0 ? void 0 : _a.classList.remove(triggerClass);
            clearTimeout(t);
            setIsFloaterOpen(false);
        }, delay);
    }, []);
    var toggleFloater = useCallback(function (isOpen) {
        if (isOpen) {
            openFloater();
        }
        else {
            closeFloater();
        }
    }, [openFloater, closeFloater]);
    var handleClickOutside = useCallback(function (event) {
        var _a;
        if (isStatic ||
            (((_a = floaterRef === null || floaterRef === void 0 ? void 0 : floaterRef.current) === null || _a === void 0 ? void 0 : _a.contains(event.target)) &&
                !hasActiveInsideClick)) {
            return;
        }
        toggleFloater(false);
    }, [hasActiveInsideClick, isStatic, toggleFloater]);
    useLayoutEffect(function () {
        if (isVisible !== undefined) {
            toggleFloater(isVisible);
        }
    }, [isVisible, toggleFloater]);
    useLayoutEffect(function () {
        if (isFloaterOpen) {
            document.addEventListener("pointerup", handleClickOutside);
        }
        else {
            document.removeEventListener("pointerup", handleClickOutside);
        }
        return function () {
            document.removeEventListener("pointerup", handleClickOutside);
        };
    }, [isFloaterOpen, handleClickOutside]);
    var additionalClasses = __spreadArray([], (isContrast ? [] : ["Floater__content--light"]), true).join(" ");
    return (_jsxs("div", __assign({ className: "Floater", ref: parentRef }, { children: [isStatic
                ? triggerEl
                : cloneElement(triggerEl, {
                    onClick: toggleFloater,
                }), _jsx("div", __assign({ ref: floaterRef, className: "Floater__content ".concat(additionalClasses) }, { children: children }))] })));
};
//# sourceMappingURL=index.js.map